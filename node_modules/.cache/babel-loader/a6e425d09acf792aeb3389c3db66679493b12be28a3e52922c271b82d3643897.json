{"ast":null,"code":"import { resolveElements } from '../render/dom/utils/resolve-element.mjs';\nimport { visualElementStore } from '../render/store.mjs';\nimport { invariant } from '../utils/errors.mjs';\nimport { GroupPlaybackControls } from './GroupPlaybackControls.mjs';\nimport { isDOMKeyframes } from './utils/is-dom-keyframes.mjs';\nimport { animateTarget } from './interfaces/visual-element-target.mjs';\nimport { createVisualElement } from './utils/create-visual-element.mjs';\nimport { animateSingleValue } from './interfaces/single-value.mjs';\nfunction animateElements(elementOrSelector, keyframes, options, scope) {\n  const elements = resolveElements(elementOrSelector, scope);\n  const numElements = elements.length;\n  invariant(Boolean(numElements), \"No valid element provided.\");\n  const animations = [];\n  for (let i = 0; i < numElements; i++) {\n    const element = elements[i];\n    /**\n     * Check each element for an associated VisualElement. If none exists,\n     * we need to create one.\n     */\n    if (!visualElementStore.has(element)) {\n      /**\n       * TODO: We only need render-specific parts of the VisualElement.\n       * With some additional work the size of the animate() function\n       * could be reduced significantly.\n       */\n      createVisualElement(element);\n    }\n    const visualElement = visualElementStore.get(element);\n    animations.push(...animateTarget(visualElement, {\n      ...keyframes,\n      transition: options\n    }, {}));\n  }\n  return new GroupPlaybackControls(animations);\n}\nconst createScopedAnimate = scope => {\n  function scopedAnimate(valueOrElement, keyframes) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let animation;\n    if (isDOMKeyframes(keyframes)) {\n      animation = animateElements(valueOrElement, keyframes, options, scope);\n    } else {\n      animation = animateSingleValue(valueOrElement, keyframes, options);\n    }\n    if (scope) {\n      scope.animations.push(animation);\n    }\n    return animation;\n  }\n  return scopedAnimate;\n};\nconst animate = createScopedAnimate();\nexport { animate, createScopedAnimate };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}